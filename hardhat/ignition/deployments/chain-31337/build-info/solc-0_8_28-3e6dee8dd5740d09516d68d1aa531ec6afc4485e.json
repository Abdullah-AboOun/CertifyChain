{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-3e6dee8dd5740d09516d68d1aa531ec6afc4485e",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/CertificateRegistry.sol": "project/contracts/CertificateRegistry.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/CertificateRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * @title CertificateRegistry\n * @dev Smart contract for managing certificate issuance, verification, and revocation\n */\ncontract CertificateRegistry {\n    \n    // Struct to store certificate data\n    struct Certificate {\n        uint256 id;\n        string certificateHash; // IPFS hash or document hash\n        address issuer;\n        address recipient;\n        uint256 issuedAt;\n        bool isRevoked;\n        string metadata; // Additional metadata (JSON string)\n    }\n    \n    // Struct to store issuing entity data\n    struct IssuingEntity {\n        address entityAddress;\n        string name;\n        bool isActive;\n        uint256 registeredAt;\n        uint256 certificateCount;\n    }\n    \n    // State variables\n    address public owner;\n    uint256 public registrationFee;\n    uint256 public certificateIssuanceFee;\n    uint256 public certificateCount;\n    \n    // Mappings\n    mapping(uint256 => Certificate) public certificates;\n    mapping(address => IssuingEntity) public issuingEntities;\n    mapping(address => bool) public isRegisteredEntity;\n    mapping(address => uint256[]) public entityCertificates;\n    mapping(address => uint256[]) public recipientCertificates;\n    \n    // Events\n    event EntityRegistered(address indexed entity, string name, uint256 timestamp);\n    event EntityDeactivated(address indexed entity, uint256 timestamp);\n    event CertificateIssued(\n        uint256 indexed certificateId,\n        address indexed issuer,\n        address indexed recipient,\n        string certificateHash,\n        uint256 timestamp\n    );\n    event CertificateRevoked(uint256 indexed certificateId, address indexed issuer, uint256 timestamp);\n    event FeeUpdated(string feeType, uint256 newFee);\n    event FeesWithdrawn(address indexed owner, uint256 amount);\n    \n    // Modifiers\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n    \n    modifier onlyRegisteredEntity() {\n        require(isRegisteredEntity[msg.sender], \"Not a registered entity\");\n        require(issuingEntities[msg.sender].isActive, \"Entity is deactivated\");\n        _;\n    }\n    \n    modifier certificateExists(uint256 _certificateId) {\n        require(_certificateId > 0 && _certificateId <= certificateCount, \"Certificate does not exist\");\n        _;\n    }\n    \n    // Constructor\n    constructor(uint256 _registrationFee, uint256 _certificateIssuanceFee) {\n        owner = msg.sender;\n        registrationFee = _registrationFee;\n        certificateIssuanceFee = _certificateIssuanceFee;\n        certificateCount = 0;\n    }\n    \n    /**\n     * @dev Register a new issuing entity\n     * @param _name Name of the issuing entity\n     */\n    function registerEntity(string memory _name) external payable {\n        require(!isRegisteredEntity[msg.sender], \"Entity already registered\");\n        require(msg.value >= registrationFee, \"Insufficient registration fee\");\n        require(bytes(_name).length > 0, \"Name cannot be empty\");\n        \n        issuingEntities[msg.sender] = IssuingEntity({\n            entityAddress: msg.sender,\n            name: _name,\n            isActive: true,\n            registeredAt: block.timestamp,\n            certificateCount: 0\n        });\n        \n        isRegisteredEntity[msg.sender] = true;\n        \n        emit EntityRegistered(msg.sender, _name, block.timestamp);\n    }\n    \n    /**\n     * @dev Issue a new certificate\n     * @param _certificateHash Hash of the certificate document\n     * @param _recipient Address of the certificate recipient\n     * @param _metadata Additional metadata\n     */\n    function issueCertificate(\n        string memory _certificateHash,\n        address _recipient,\n        string memory _metadata\n    ) external payable onlyRegisteredEntity returns (uint256) {\n        require(msg.value >= certificateIssuanceFee, \"Insufficient issuance fee\");\n        require(bytes(_certificateHash).length > 0, \"Certificate hash cannot be empty\");\n        require(_recipient != address(0), \"Invalid recipient address\");\n        \n        certificateCount++;\n        \n        certificates[certificateCount] = Certificate({\n            id: certificateCount,\n            certificateHash: _certificateHash,\n            issuer: msg.sender,\n            recipient: _recipient,\n            issuedAt: block.timestamp,\n            isRevoked: false,\n            metadata: _metadata\n        });\n        \n        entityCertificates[msg.sender].push(certificateCount);\n        recipientCertificates[_recipient].push(certificateCount);\n        issuingEntities[msg.sender].certificateCount++;\n        \n        emit CertificateIssued(certificateCount, msg.sender, _recipient, _certificateHash, block.timestamp);\n        \n        return certificateCount;\n    }\n    \n    /**\n     * @dev Revoke a certificate\n     * @param _certificateId ID of the certificate to revoke\n     */\n    function revokeCertificate(uint256 _certificateId) \n        external \n        onlyRegisteredEntity \n        certificateExists(_certificateId) \n    {\n        Certificate storage cert = certificates[_certificateId];\n        require(cert.issuer == msg.sender, \"Only issuer can revoke\");\n        require(!cert.isRevoked, \"Certificate already revoked\");\n        \n        cert.isRevoked = true;\n        \n        emit CertificateRevoked(_certificateId, msg.sender, block.timestamp);\n    }\n    \n    /**\n     * @dev Verify a certificate\n     * @param _certificateId ID of the certificate\n     * @return id Certificate ID\n     * @return certificateHash Hash of the certificate\n     * @return issuer Address of the issuer\n     * @return recipient Address of the recipient\n     * @return issuedAt Timestamp when issued\n     * @return isRevoked Whether the certificate is revoked\n     * @return metadata Additional metadata\n     * @return issuerName Name of the issuing entity\n     */\n    function verifyCertificate(uint256 _certificateId) \n        external \n        view \n        certificateExists(_certificateId) \n        returns (\n            uint256 id,\n            string memory certificateHash,\n            address issuer,\n            address recipient,\n            uint256 issuedAt,\n            bool isRevoked,\n            string memory metadata,\n            string memory issuerName\n        ) \n    {\n        Certificate memory cert = certificates[_certificateId];\n        IssuingEntity memory entity = issuingEntities[cert.issuer];\n        \n        return (\n            cert.id,\n            cert.certificateHash,\n            cert.issuer,\n            cert.recipient,\n            cert.issuedAt,\n            cert.isRevoked,\n            cert.metadata,\n            entity.name\n        );\n    }\n    \n    /**\n     * @dev Get all certificates issued by an entity\n     * @param _entity Address of the issuing entity\n     * @return Array of certificate IDs\n     */\n    function getEntityCertificates(address _entity) external view returns (uint256[] memory) {\n        return entityCertificates[_entity];\n    }\n    \n    /**\n     * @dev Get all certificates for a recipient\n     * @param _recipient Address of the recipient\n     * @return Array of certificate IDs\n     */\n    function getRecipientCertificates(address _recipient) external view returns (uint256[] memory) {\n        return recipientCertificates[_recipient];\n    }\n    \n    /**\n     * @dev Get entity information\n     * @param _entity Address of the entity\n     * @return entityAddress Address of the entity\n     * @return name Name of the entity\n     * @return isActive Whether the entity is active\n     * @return registeredAt Timestamp when registered\n     * @return certCount Number of certificates issued\n     */\n    function getEntityInfo(address _entity) \n        external \n        view \n        returns (\n            address entityAddress,\n            string memory name,\n            bool isActive,\n            uint256 registeredAt,\n            uint256 certCount\n        ) \n    {\n        IssuingEntity memory entity = issuingEntities[_entity];\n        return (\n            entity.entityAddress,\n            entity.name,\n            entity.isActive,\n            entity.registeredAt,\n            entity.certificateCount\n        );\n    }\n    \n    /**\n     * @dev Deactivate an entity (only owner)\n     * @param _entity Address of the entity to deactivate\n     */\n    function deactivateEntity(address _entity) external onlyOwner {\n        require(isRegisteredEntity[_entity], \"Entity not registered\");\n        issuingEntities[_entity].isActive = false;\n        emit EntityDeactivated(_entity, block.timestamp);\n    }\n    \n    /**\n     * @dev Activate an entity (only owner)\n     * @param _entity Address of the entity to activate\n     */\n    function activateEntity(address _entity) external onlyOwner {\n        require(isRegisteredEntity[_entity], \"Entity not registered\");\n        issuingEntities[_entity].isActive = true;\n        emit EntityRegistered(_entity, issuingEntities[_entity].name, block.timestamp);\n    }\n    \n    /**\n     * @dev Update registration fee (only owner)\n     * @param _newFee New registration fee\n     */\n    function updateRegistrationFee(uint256 _newFee) external onlyOwner {\n        registrationFee = _newFee;\n        emit FeeUpdated(\"registration\", _newFee);\n    }\n    \n    /**\n     * @dev Update certificate issuance fee (only owner)\n     * @param _newFee New issuance fee\n     */\n    function updateIssuanceFee(uint256 _newFee) external onlyOwner {\n        certificateIssuanceFee = _newFee;\n        emit FeeUpdated(\"issuance\", _newFee);\n    }\n    \n    /**\n     * @dev Withdraw collected fees (only owner)\n     */\n    function withdrawFees() external onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No fees to withdraw\");\n        \n        (bool success, ) = owner.call{value: balance}(\"\");\n        require(success, \"Withdrawal failed\");\n        \n        emit FeesWithdrawn(owner, balance);\n    }\n    \n    /**\n     * @dev Get contract balance\n     */\n    function getContractBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n"
      }
    }
  }
}